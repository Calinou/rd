/// When seccomp decides not to execute a syscall the kernel returns to userspace
/// without modifying the registers. There is no negative return value to
/// indicate that whatever side effects the syscall would happen did not take
/// place. This is a problem for rd, because for syscalls that require special
/// handling, we'll be performing that handling even though the syscall didn't
/// actually happen.
///
/// To get around this we can use the same mechanism that is used to skip the
/// syscall in the kernel to skip it ourselves: original_syscallno. We can't
/// use the traditional value of -1 though, because the kernel initializes
/// original_syscallno to -1 when delivering signals, and exiting sigreturn
/// will restore that. Not recording the side effects of sigreturn would be
/// bad. Instead we use -2, which still causes skipping the syscall when
/// given to the kernel as original_syscallno, but is never generated by the
/// kernel itself.
pub const SECCOMP_MAGIC_SKIP_ORIGINAL_SYSCALLNO: isize = -2;

pub struct SeccompFilterRewriter;
